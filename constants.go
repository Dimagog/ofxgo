package ofxgo

/*
 * Do not edit this file by hand. It is auto-generated by calling `go generate`.
 * To make changes, edit generate_constants.py, re-run `go generate`, and check
 * in the result.
 */

import (
	"errors"
	"fmt"
	"github.com/aclindsa/go/src/encoding/xml"
	"strings"
)

type acctType uint

const (
	AcctTypeChecking acctType = 1 + iota
	AcctTypeSavings
	AcctTypeMoneyMrkt
	AcctTypeCreditLine
	AcctTypeCD
)

var acctTypes = [...]string{"CHECKING", "SAVINGS", "MONEYMRKT", "CREDITLINE", "CD"}

func (e acctType) Valid() bool {
	return e >= AcctTypeChecking && e <= AcctTypeCD
}

func (e acctType) String() string {
	if e.Valid() {
		return acctTypes[e-1]
	}
	return fmt.Sprintf("invalid acctType (%d)", e)
}

func (e *acctType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range acctTypes {
		if s == value {
			*e = acctType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid AcctType: \"" + in + "\"")
}

func (e *acctType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *acctType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid AcctType")
	}
	enc.EncodeElement(acctTypes[*e-1], start)
	return nil
}

func NewAcctType(s string) (acctType, error) {
	var e acctType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type trnType uint

const (
	TrnTypeCredit trnType = 1 + iota
	TrnTypeDebit
	TrnTypeInt
	TrnTypeDiv
	TrnTypeFee
	TrnTypeSrvChg
	TrnTypeDep
	TrnTypeATM
	TrnTypePOS
	TrnTypeXfer
	TrnTypeCheck
	TrnTypePayment
	TrnTypeCash
	TrnTypeDirectDep
	TrnTypeDirectDebit
	TrnTypeRepeatPmt
	TrnTypeHold
	TrnTypeOther
)

var trnTypes = [...]string{"CREDIT", "DEBIT", "INT", "DIV", "FEE", "SRVCHG", "DEP", "ATM", "POS", "XFER", "CHECK", "PAYMENT", "CASH", "DIRECTDEP", "DIRECTDEBIT", "REPEATPMT", "HOLD", "OTHER"}

func (e trnType) Valid() bool {
	return e >= TrnTypeCredit && e <= TrnTypeOther
}

func (e trnType) String() string {
	if e.Valid() {
		return trnTypes[e-1]
	}
	return fmt.Sprintf("invalid trnType (%d)", e)
}

func (e *trnType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range trnTypes {
		if s == value {
			*e = trnType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid TrnType: \"" + in + "\"")
}

func (e *trnType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *trnType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid TrnType")
	}
	enc.EncodeElement(trnTypes[*e-1], start)
	return nil
}

func NewTrnType(s string) (trnType, error) {
	var e trnType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type imageType uint

const (
	ImageTypeStatement imageType = 1 + iota
	ImageTypeTransaction
	ImageTypeTax
)

var imageTypes = [...]string{"STATEMENT", "TRANSACTION", "TAX"}

func (e imageType) Valid() bool {
	return e >= ImageTypeStatement && e <= ImageTypeTax
}

func (e imageType) String() string {
	if e.Valid() {
		return imageTypes[e-1]
	}
	return fmt.Sprintf("invalid imageType (%d)", e)
}

func (e *imageType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range imageTypes {
		if s == value {
			*e = imageType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid ImageType: \"" + in + "\"")
}

func (e *imageType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *imageType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid ImageType")
	}
	enc.EncodeElement(imageTypes[*e-1], start)
	return nil
}

func NewImageType(s string) (imageType, error) {
	var e imageType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type imageRefType uint

const (
	ImageRefTypeOpaque imageRefType = 1 + iota
	ImageRefTypeURL
	ImageRefTypeFormURL
)

var imageRefTypes = [...]string{"OPAQUE", "URL", "FORMURL"}

func (e imageRefType) Valid() bool {
	return e >= ImageRefTypeOpaque && e <= ImageRefTypeFormURL
}

func (e imageRefType) String() string {
	if e.Valid() {
		return imageRefTypes[e-1]
	}
	return fmt.Sprintf("invalid imageRefType (%d)", e)
}

func (e *imageRefType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range imageRefTypes {
		if s == value {
			*e = imageRefType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid ImageRefType: \"" + in + "\"")
}

func (e *imageRefType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *imageRefType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid ImageRefType")
	}
	enc.EncodeElement(imageRefTypes[*e-1], start)
	return nil
}

func NewImageRefType(s string) (imageRefType, error) {
	var e imageRefType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type checkSup uint

const (
	CheckSupFrontOnly checkSup = 1 + iota
	CheckSupBackOnly
	CheckSupFrontAndBack
)

var checkSups = [...]string{"FRONTONLY", "BACKONLY", "FRONTANDBACK"}

func (e checkSup) Valid() bool {
	return e >= CheckSupFrontOnly && e <= CheckSupFrontAndBack
}

func (e checkSup) String() string {
	if e.Valid() {
		return checkSups[e-1]
	}
	return fmt.Sprintf("invalid checkSup (%d)", e)
}

func (e *checkSup) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range checkSups {
		if s == value {
			*e = checkSup(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid CheckSup: \"" + in + "\"")
}

func (e *checkSup) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *checkSup) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid CheckSup")
	}
	enc.EncodeElement(checkSups[*e-1], start)
	return nil
}

func NewCheckSup(s string) (checkSup, error) {
	var e checkSup
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type correctAction uint

const (
	CorrectActionDelete correctAction = 1 + iota
	CorrectActionReplace
)

var correctActions = [...]string{"DELETE", "REPLACE"}

func (e correctAction) Valid() bool {
	return e >= CorrectActionDelete && e <= CorrectActionReplace
}

func (e correctAction) String() string {
	if e.Valid() {
		return correctActions[e-1]
	}
	return fmt.Sprintf("invalid correctAction (%d)", e)
}

func (e *correctAction) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range correctActions {
		if s == value {
			*e = correctAction(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid CorrectAction: \"" + in + "\"")
}

func (e *correctAction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *correctAction) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid CorrectAction")
	}
	enc.EncodeElement(correctActions[*e-1], start)
	return nil
}

func NewCorrectAction(s string) (correctAction, error) {
	var e correctAction
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type balType uint

const (
	BalTypeDollar balType = 1 + iota
	BalTypePercent
	BalTypeNumber
)

var balTypes = [...]string{"DOLLAR", "PERCENT", "NUMBER"}

func (e balType) Valid() bool {
	return e >= BalTypeDollar && e <= BalTypeNumber
}

func (e balType) String() string {
	if e.Valid() {
		return balTypes[e-1]
	}
	return fmt.Sprintf("invalid balType (%d)", e)
}

func (e *balType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range balTypes {
		if s == value {
			*e = balType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid BalType: \"" + in + "\"")
}

func (e *balType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *balType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid BalType")
	}
	enc.EncodeElement(balTypes[*e-1], start)
	return nil
}

func NewBalType(s string) (balType, error) {
	var e balType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type inv401kSource uint

const (
	Inv401kSourcePreTax inv401kSource = 1 + iota
	Inv401kSourceAfterTax
	Inv401kSourceMatch
	Inv401kSourceProfitSharing
	Inv401kSourceRollover
	Inv401kSourceOtherVest
	Inv401kSourceOtherNonVest
)

var inv401kSources = [...]string{"PRETAX", "AFTERTAX", "MATCH", "PROFITSHARING", "ROLLOVER", "OTHERVEST", "OTHERNONVEST"}

func (e inv401kSource) Valid() bool {
	return e >= Inv401kSourcePreTax && e <= Inv401kSourceOtherNonVest
}

func (e inv401kSource) String() string {
	if e.Valid() {
		return inv401kSources[e-1]
	}
	return fmt.Sprintf("invalid inv401kSource (%d)", e)
}

func (e *inv401kSource) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range inv401kSources {
		if s == value {
			*e = inv401kSource(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid Inv401kSource: \"" + in + "\"")
}

func (e *inv401kSource) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *inv401kSource) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid Inv401kSource")
	}
	enc.EncodeElement(inv401kSources[*e-1], start)
	return nil
}

func NewInv401kSource(s string) (inv401kSource, error) {
	var e inv401kSource
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type subAcctType uint

const (
	SubAcctTypeCash subAcctType = 1 + iota
	SubAcctTypeMargin
	SubAcctTypeShort
	SubAcctTypeOther
)

var subAcctTypes = [...]string{"CASH", "MARGIN", "SHORT", "OTHER"}

func (e subAcctType) Valid() bool {
	return e >= SubAcctTypeCash && e <= SubAcctTypeOther
}

func (e subAcctType) String() string {
	if e.Valid() {
		return subAcctTypes[e-1]
	}
	return fmt.Sprintf("invalid subAcctType (%d)", e)
}

func (e *subAcctType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range subAcctTypes {
		if s == value {
			*e = subAcctType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid SubAcctType: \"" + in + "\"")
}

func (e *subAcctType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *subAcctType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid SubAcctType")
	}
	enc.EncodeElement(subAcctTypes[*e-1], start)
	return nil
}

func NewSubAcctType(s string) (subAcctType, error) {
	var e subAcctType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type buyType uint

const (
	BuyTypeBuy buyType = 1 + iota
	BuyTypeBuyToCover
)

var buyTypes = [...]string{"BUY", "BUYTOCOVER"}

func (e buyType) Valid() bool {
	return e >= BuyTypeBuy && e <= BuyTypeBuyToCover
}

func (e buyType) String() string {
	if e.Valid() {
		return buyTypes[e-1]
	}
	return fmt.Sprintf("invalid buyType (%d)", e)
}

func (e *buyType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range buyTypes {
		if s == value {
			*e = buyType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid BuyType: \"" + in + "\"")
}

func (e *buyType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *buyType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid BuyType")
	}
	enc.EncodeElement(buyTypes[*e-1], start)
	return nil
}

func NewBuyType(s string) (buyType, error) {
	var e buyType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type optAction uint

const (
	OptActionExercise optAction = 1 + iota
	OptActionAssign
	OptActionExpire
)

var optActions = [...]string{"EXERCISE", "ASSIGN", "EXPIRE"}

func (e optAction) Valid() bool {
	return e >= OptActionExercise && e <= OptActionExpire
}

func (e optAction) String() string {
	if e.Valid() {
		return optActions[e-1]
	}
	return fmt.Sprintf("invalid optAction (%d)", e)
}

func (e *optAction) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range optActions {
		if s == value {
			*e = optAction(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid OptAction: \"" + in + "\"")
}

func (e *optAction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *optAction) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid OptAction")
	}
	enc.EncodeElement(optActions[*e-1], start)
	return nil
}

func NewOptAction(s string) (optAction, error) {
	var e optAction
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type tferAction uint

const (
	TferActionIn tferAction = 1 + iota
	TferActionOut
)

var tferActions = [...]string{"IN", "OUT"}

func (e tferAction) Valid() bool {
	return e >= TferActionIn && e <= TferActionOut
}

func (e tferAction) String() string {
	if e.Valid() {
		return tferActions[e-1]
	}
	return fmt.Sprintf("invalid tferAction (%d)", e)
}

func (e *tferAction) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range tferActions {
		if s == value {
			*e = tferAction(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid TferAction: \"" + in + "\"")
}

func (e *tferAction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *tferAction) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid TferAction")
	}
	enc.EncodeElement(tferActions[*e-1], start)
	return nil
}

func NewTferAction(s string) (tferAction, error) {
	var e tferAction
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type posType uint

const (
	PosTypeLong posType = 1 + iota
	PosTypeShort
)

var posTypes = [...]string{"LONG", "SHORT"}

func (e posType) Valid() bool {
	return e >= PosTypeLong && e <= PosTypeShort
}

func (e posType) String() string {
	if e.Valid() {
		return posTypes[e-1]
	}
	return fmt.Sprintf("invalid posType (%d)", e)
}

func (e *posType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range posTypes {
		if s == value {
			*e = posType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid PosType: \"" + in + "\"")
}

func (e *posType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *posType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid PosType")
	}
	enc.EncodeElement(posTypes[*e-1], start)
	return nil
}

func NewPosType(s string) (posType, error) {
	var e posType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type secured uint

const (
	SecuredNaked secured = 1 + iota
	SecuredCovered
)

var secureds = [...]string{"NAKED", "COVERED"}

func (e secured) Valid() bool {
	return e >= SecuredNaked && e <= SecuredCovered
}

func (e secured) String() string {
	if e.Valid() {
		return secureds[e-1]
	}
	return fmt.Sprintf("invalid secured (%d)", e)
}

func (e *secured) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range secureds {
		if s == value {
			*e = secured(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid Secured: \"" + in + "\"")
}

func (e *secured) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *secured) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid Secured")
	}
	enc.EncodeElement(secureds[*e-1], start)
	return nil
}

func NewSecured(s string) (secured, error) {
	var e secured
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type duration uint

const (
	DurationDay duration = 1 + iota
	DurationGoodTilCancel
	DurationImmediate
)

var durations = [...]string{"DAY", "GOODTILCANCEL", "IMMEDIATE"}

func (e duration) Valid() bool {
	return e >= DurationDay && e <= DurationImmediate
}

func (e duration) String() string {
	if e.Valid() {
		return durations[e-1]
	}
	return fmt.Sprintf("invalid duration (%d)", e)
}

func (e *duration) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range durations {
		if s == value {
			*e = duration(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid Duration: \"" + in + "\"")
}

func (e *duration) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *duration) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid Duration")
	}
	enc.EncodeElement(durations[*e-1], start)
	return nil
}

func NewDuration(s string) (duration, error) {
	var e duration
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type restriction uint

const (
	RestrictionAllOrNone restriction = 1 + iota
	RestrictionMinUnits
	RestrictionNone
)

var restrictions = [...]string{"ALLORNONE", "MINUNITS", "NONE"}

func (e restriction) Valid() bool {
	return e >= RestrictionAllOrNone && e <= RestrictionNone
}

func (e restriction) String() string {
	if e.Valid() {
		return restrictions[e-1]
	}
	return fmt.Sprintf("invalid restriction (%d)", e)
}

func (e *restriction) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range restrictions {
		if s == value {
			*e = restriction(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid Restriction: \"" + in + "\"")
}

func (e *restriction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *restriction) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid Restriction")
	}
	enc.EncodeElement(restrictions[*e-1], start)
	return nil
}

func NewRestriction(s string) (restriction, error) {
	var e restriction
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type unitType uint

const (
	UnitTypeShares unitType = 1 + iota
	UnitTypeCurrency
)

var unitTypes = [...]string{"SHARES", "CURRENCY"}

func (e unitType) Valid() bool {
	return e >= UnitTypeShares && e <= UnitTypeCurrency
}

func (e unitType) String() string {
	if e.Valid() {
		return unitTypes[e-1]
	}
	return fmt.Sprintf("invalid unitType (%d)", e)
}

func (e *unitType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range unitTypes {
		if s == value {
			*e = unitType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid UnitType: \"" + in + "\"")
}

func (e *unitType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *unitType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid UnitType")
	}
	enc.EncodeElement(unitTypes[*e-1], start)
	return nil
}

func NewUnitType(s string) (unitType, error) {
	var e unitType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type optBuyType uint

const (
	OptBuyTypeBuyToOpen optBuyType = 1 + iota
	OptBuyTypeBuyToClose
)

var optBuyTypes = [...]string{"BUYTOOPEN", "BUYTOCLOSE"}

func (e optBuyType) Valid() bool {
	return e >= OptBuyTypeBuyToOpen && e <= OptBuyTypeBuyToClose
}

func (e optBuyType) String() string {
	if e.Valid() {
		return optBuyTypes[e-1]
	}
	return fmt.Sprintf("invalid optBuyType (%d)", e)
}

func (e *optBuyType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range optBuyTypes {
		if s == value {
			*e = optBuyType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid OptBuyType: \"" + in + "\"")
}

func (e *optBuyType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *optBuyType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid OptBuyType")
	}
	enc.EncodeElement(optBuyTypes[*e-1], start)
	return nil
}

func NewOptBuyType(s string) (optBuyType, error) {
	var e optBuyType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type sellType uint

const (
	SellTypeSell sellType = 1 + iota
	SellTypeSellShort
)

var sellTypes = [...]string{"SELL", "SELLSHORT"}

func (e sellType) Valid() bool {
	return e >= SellTypeSell && e <= SellTypeSellShort
}

func (e sellType) String() string {
	if e.Valid() {
		return sellTypes[e-1]
	}
	return fmt.Sprintf("invalid sellType (%d)", e)
}

func (e *sellType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range sellTypes {
		if s == value {
			*e = sellType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid SellType: \"" + in + "\"")
}

func (e *sellType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *sellType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid SellType")
	}
	enc.EncodeElement(sellTypes[*e-1], start)
	return nil
}

func NewSellType(s string) (sellType, error) {
	var e sellType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type loanPmtFreq uint

const (
	LoanPmtFreqWeekly loanPmtFreq = 1 + iota
	LoanPmtFreqBiweekly
	LoanPmtFreqTwiceMonthly
	LoanPmtFreqMonthly
	LoanPmtFreqFourWeeks
	LoanPmtFreqBiMonthly
	LoanPmtFreqQuarterly
	LoanPmtFreqSemiannually
	LoanPmtFreqAnnually
	LoanPmtFreqOther
)

var loanPmtFreqs = [...]string{"WEEKLY", "BIWEEKLY", "TWICEMONTHLY", "MONTHLY", "FOURWEEKS", "BIMONTHLY", "QUARTERLY", "SEMIANNUALLY", "ANNUALLY", "OTHER"}

func (e loanPmtFreq) Valid() bool {
	return e >= LoanPmtFreqWeekly && e <= LoanPmtFreqOther
}

func (e loanPmtFreq) String() string {
	if e.Valid() {
		return loanPmtFreqs[e-1]
	}
	return fmt.Sprintf("invalid loanPmtFreq (%d)", e)
}

func (e *loanPmtFreq) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range loanPmtFreqs {
		if s == value {
			*e = loanPmtFreq(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid LoanPmtFreq: \"" + in + "\"")
}

func (e *loanPmtFreq) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *loanPmtFreq) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid LoanPmtFreq")
	}
	enc.EncodeElement(loanPmtFreqs[*e-1], start)
	return nil
}

func NewLoanPmtFreq(s string) (loanPmtFreq, error) {
	var e loanPmtFreq
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type incomeType uint

const (
	IncomeTypeCGLong incomeType = 1 + iota
	IncomeTypeCGShort
	IncomeTypeDiv
	IncomeTypeInterest
	IncomeTypeMisc
)

var incomeTypes = [...]string{"CGLONG", "CGSHORT", "DIV", "INTEREST", "MISC"}

func (e incomeType) Valid() bool {
	return e >= IncomeTypeCGLong && e <= IncomeTypeMisc
}

func (e incomeType) String() string {
	if e.Valid() {
		return incomeTypes[e-1]
	}
	return fmt.Sprintf("invalid incomeType (%d)", e)
}

func (e *incomeType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range incomeTypes {
		if s == value {
			*e = incomeType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid IncomeType: \"" + in + "\"")
}

func (e *incomeType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *incomeType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid IncomeType")
	}
	enc.EncodeElement(incomeTypes[*e-1], start)
	return nil
}

func NewIncomeType(s string) (incomeType, error) {
	var e incomeType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type sellReason uint

const (
	SellReasonCall sellReason = 1 + iota
	SellReasonSell
	SellReasonMaturity
)

var sellReasons = [...]string{"CALL", "SELL", "MATURITY"}

func (e sellReason) Valid() bool {
	return e >= SellReasonCall && e <= SellReasonMaturity
}

func (e sellReason) String() string {
	if e.Valid() {
		return sellReasons[e-1]
	}
	return fmt.Sprintf("invalid sellReason (%d)", e)
}

func (e *sellReason) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range sellReasons {
		if s == value {
			*e = sellReason(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid SellReason: \"" + in + "\"")
}

func (e *sellReason) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *sellReason) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid SellReason")
	}
	enc.EncodeElement(sellReasons[*e-1], start)
	return nil
}

func NewSellReason(s string) (sellReason, error) {
	var e sellReason
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type optSellType uint

const (
	OptSellTypeSellToClose optSellType = 1 + iota
	OptSellTypeSellToOpen
)

var optSellTypes = [...]string{"SELLTOCLOSE", "SELLTOOPEN"}

func (e optSellType) Valid() bool {
	return e >= OptSellTypeSellToClose && e <= OptSellTypeSellToOpen
}

func (e optSellType) String() string {
	if e.Valid() {
		return optSellTypes[e-1]
	}
	return fmt.Sprintf("invalid optSellType (%d)", e)
}

func (e *optSellType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range optSellTypes {
		if s == value {
			*e = optSellType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid OptSellType: \"" + in + "\"")
}

func (e *optSellType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *optSellType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid OptSellType")
	}
	enc.EncodeElement(optSellTypes[*e-1], start)
	return nil
}

func NewOptSellType(s string) (optSellType, error) {
	var e optSellType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type relType uint

const (
	RelTypeSpread relType = 1 + iota
	RelTypeStraddle
	RelTypeNone
	RelTypeOther
)

var relTypes = [...]string{"SPREAD", "STRADDLE", "NONE", "OTHER"}

func (e relType) Valid() bool {
	return e >= RelTypeSpread && e <= RelTypeOther
}

func (e relType) String() string {
	if e.Valid() {
		return relTypes[e-1]
	}
	return fmt.Sprintf("invalid relType (%d)", e)
}

func (e *relType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range relTypes {
		if s == value {
			*e = relType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid RelType: \"" + in + "\"")
}

func (e *relType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *relType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid RelType")
	}
	enc.EncodeElement(relTypes[*e-1], start)
	return nil
}

func NewRelType(s string) (relType, error) {
	var e relType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type charType uint

const (
	CharTypeAlphaOnly charType = 1 + iota
	CharTypeNumericOnly
	CharTypeAlphaOrNumeric
	CharTypeAlphaAndNumeric
)

var charTypes = [...]string{"ALPHAONLY", "NUMERICONLY", "ALPHAORNUMERIC", "ALPHAANDNUMERIC"}

func (e charType) Valid() bool {
	return e >= CharTypeAlphaOnly && e <= CharTypeAlphaAndNumeric
}

func (e charType) String() string {
	if e.Valid() {
		return charTypes[e-1]
	}
	return fmt.Sprintf("invalid charType (%d)", e)
}

func (e *charType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range charTypes {
		if s == value {
			*e = charType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid CharType: \"" + in + "\"")
}

func (e *charType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *charType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid CharType")
	}
	enc.EncodeElement(charTypes[*e-1], start)
	return nil
}

func NewCharType(s string) (charType, error) {
	var e charType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type syncMode uint

const (
	SyncModeFull syncMode = 1 + iota
	SyncModeLite
)

var syncModes = [...]string{"FULL", "LITE"}

func (e syncMode) Valid() bool {
	return e >= SyncModeFull && e <= SyncModeLite
}

func (e syncMode) String() string {
	if e.Valid() {
		return syncModes[e-1]
	}
	return fmt.Sprintf("invalid syncMode (%d)", e)
}

func (e *syncMode) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range syncModes {
		if s == value {
			*e = syncMode(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid SyncMode: \"" + in + "\"")
}

func (e *syncMode) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *syncMode) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid SyncMode")
	}
	enc.EncodeElement(syncModes[*e-1], start)
	return nil
}

func NewSyncMode(s string) (syncMode, error) {
	var e syncMode
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type debtType uint

const (
	DebtTypeCoupon debtType = 1 + iota
	DebtTypeZero
)

var debtTypes = [...]string{"COUPON", "ZERO"}

func (e debtType) Valid() bool {
	return e >= DebtTypeCoupon && e <= DebtTypeZero
}

func (e debtType) String() string {
	if e.Valid() {
		return debtTypes[e-1]
	}
	return fmt.Sprintf("invalid debtType (%d)", e)
}

func (e *debtType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range debtTypes {
		if s == value {
			*e = debtType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid DebtType: \"" + in + "\"")
}

func (e *debtType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *debtType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid DebtType")
	}
	enc.EncodeElement(debtTypes[*e-1], start)
	return nil
}

func NewDebtType(s string) (debtType, error) {
	var e debtType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type debtClass uint

const (
	DebtClassTreasury debtClass = 1 + iota
	DebtClassMunicipal
	DebtClassCorporate
	DebtClassOther
)

var debtClasss = [...]string{"TREASURY", "MUNICIPAL", "CORPORATE", "OTHER"}

func (e debtClass) Valid() bool {
	return e >= DebtClassTreasury && e <= DebtClassOther
}

func (e debtClass) String() string {
	if e.Valid() {
		return debtClasss[e-1]
	}
	return fmt.Sprintf("invalid debtClass (%d)", e)
}

func (e *debtClass) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range debtClasss {
		if s == value {
			*e = debtClass(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid DebtClass: \"" + in + "\"")
}

func (e *debtClass) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *debtClass) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid DebtClass")
	}
	enc.EncodeElement(debtClasss[*e-1], start)
	return nil
}

func NewDebtClass(s string) (debtClass, error) {
	var e debtClass
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type couponFreq uint

const (
	CouponFreqMonthly couponFreq = 1 + iota
	CouponFreqQuarterly
	CouponFreqSemiannual
	CouponFreqAnnual
	CouponFreqOther
)

var couponFreqs = [...]string{"MONTHLY", "QUARTERLY", "SEMIANNUAL", "ANNUAL", "OTHER"}

func (e couponFreq) Valid() bool {
	return e >= CouponFreqMonthly && e <= CouponFreqOther
}

func (e couponFreq) String() string {
	if e.Valid() {
		return couponFreqs[e-1]
	}
	return fmt.Sprintf("invalid couponFreq (%d)", e)
}

func (e *couponFreq) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range couponFreqs {
		if s == value {
			*e = couponFreq(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid CouponFreq: \"" + in + "\"")
}

func (e *couponFreq) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *couponFreq) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid CouponFreq")
	}
	enc.EncodeElement(couponFreqs[*e-1], start)
	return nil
}

func NewCouponFreq(s string) (couponFreq, error) {
	var e couponFreq
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type callType uint

const (
	CallTypeCall callType = 1 + iota
	CallTypePut
	CallTypePrefund
	CallTypeMaturity
)

var callTypes = [...]string{"CALL", "PUT", "PREFUND", "MATURITY"}

func (e callType) Valid() bool {
	return e >= CallTypeCall && e <= CallTypeMaturity
}

func (e callType) String() string {
	if e.Valid() {
		return callTypes[e-1]
	}
	return fmt.Sprintf("invalid callType (%d)", e)
}

func (e *callType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range callTypes {
		if s == value {
			*e = callType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid CallType: \"" + in + "\"")
}

func (e *callType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *callType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid CallType")
	}
	enc.EncodeElement(callTypes[*e-1], start)
	return nil
}

func NewCallType(s string) (callType, error) {
	var e callType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type assetClass uint

const (
	AssetClassDomesticBond assetClass = 1 + iota
	AssetClassIntlBond
	AssetClassLargeStock
	AssetClassSmallStock
	AssetClassIntlStock
	AssetClassMoneyMrkt
	AssetClassOther
)

var assetClasss = [...]string{"DOMESTICBOND", "INTLBOND", "LARGESTOCK", "SMALLSTOCK", "INTLSTOCK", "MONEYMRKT", "OTHER"}

func (e assetClass) Valid() bool {
	return e >= AssetClassDomesticBond && e <= AssetClassOther
}

func (e assetClass) String() string {
	if e.Valid() {
		return assetClasss[e-1]
	}
	return fmt.Sprintf("invalid assetClass (%d)", e)
}

func (e *assetClass) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range assetClasss {
		if s == value {
			*e = assetClass(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid AssetClass: \"" + in + "\"")
}

func (e *assetClass) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *assetClass) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid AssetClass")
	}
	enc.EncodeElement(assetClasss[*e-1], start)
	return nil
}

func NewAssetClass(s string) (assetClass, error) {
	var e assetClass
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type mfType uint

const (
	MfTypeOpenEnd mfType = 1 + iota
	MfTypeCloseEnd
	MfTypeOther
)

var mfTypes = [...]string{"OPENEND", "CLOSEEND", "OTHER"}

func (e mfType) Valid() bool {
	return e >= MfTypeOpenEnd && e <= MfTypeOther
}

func (e mfType) String() string {
	if e.Valid() {
		return mfTypes[e-1]
	}
	return fmt.Sprintf("invalid mfType (%d)", e)
}

func (e *mfType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range mfTypes {
		if s == value {
			*e = mfType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid MfType: \"" + in + "\"")
}

func (e *mfType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *mfType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid MfType")
	}
	enc.EncodeElement(mfTypes[*e-1], start)
	return nil
}

func NewMfType(s string) (mfType, error) {
	var e mfType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type optType uint

const (
	OptTypePut optType = 1 + iota
	OptTypeCall
)

var optTypes = [...]string{"PUT", "CALL"}

func (e optType) Valid() bool {
	return e >= OptTypePut && e <= OptTypeCall
}

func (e optType) String() string {
	if e.Valid() {
		return optTypes[e-1]
	}
	return fmt.Sprintf("invalid optType (%d)", e)
}

func (e *optType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range optTypes {
		if s == value {
			*e = optType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid OptType: \"" + in + "\"")
}

func (e *optType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *optType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid OptType")
	}
	enc.EncodeElement(optTypes[*e-1], start)
	return nil
}

func NewOptType(s string) (optType, error) {
	var e optType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type stockType uint

const (
	StockTypeCommon stockType = 1 + iota
	StockTypePreferred
	StockTypeConvertible
	StockTypeOther
)

var stockTypes = [...]string{"COMMON", "PREFERRED", "CONVERTIBLE", "OTHER"}

func (e stockType) Valid() bool {
	return e >= StockTypeCommon && e <= StockTypeOther
}

func (e stockType) String() string {
	if e.Valid() {
		return stockTypes[e-1]
	}
	return fmt.Sprintf("invalid stockType (%d)", e)
}

func (e *stockType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range stockTypes {
		if s == value {
			*e = stockType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid StockType: \"" + in + "\"")
}

func (e *stockType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *stockType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid StockType")
	}
	enc.EncodeElement(stockTypes[*e-1], start)
	return nil
}

func NewStockType(s string) (stockType, error) {
	var e stockType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type ofxSec uint

const (
	OfxSecNone ofxSec = 1 + iota
	OfxSecType1
)

var ofxSecs = [...]string{"NONE", "TYPE 1"}

func (e ofxSec) Valid() bool {
	return e >= OfxSecNone && e <= OfxSecType1
}

func (e ofxSec) String() string {
	if e.Valid() {
		return ofxSecs[e-1]
	}
	return fmt.Sprintf("invalid ofxSec (%d)", e)
}

func (e *ofxSec) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range ofxSecs {
		if s == value {
			*e = ofxSec(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid OfxSec: \"" + in + "\"")
}

func (e *ofxSec) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *ofxSec) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid OfxSec")
	}
	enc.EncodeElement(ofxSecs[*e-1], start)
	return nil
}

func NewOfxSec(s string) (ofxSec, error) {
	var e ofxSec
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type holderType uint

const (
	HolderTypeIndividual holderType = 1 + iota
	HolderTypeJoint
	HolderTypeCustodial
	HolderTypeTrust
	HolderTypeOther
)

var holderTypes = [...]string{"INDIVIDUAL", "JOINT", "CUSTODIAL", "TRUST", "OTHER"}

func (e holderType) Valid() bool {
	return e >= HolderTypeIndividual && e <= HolderTypeOther
}

func (e holderType) String() string {
	if e.Valid() {
		return holderTypes[e-1]
	}
	return fmt.Sprintf("invalid holderType (%d)", e)
}

func (e *holderType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range holderTypes {
		if s == value {
			*e = holderType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid HolderType: \"" + in + "\"")
}

func (e *holderType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *holderType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid HolderType")
	}
	enc.EncodeElement(holderTypes[*e-1], start)
	return nil
}

func NewHolderType(s string) (holderType, error) {
	var e holderType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type acctClassification uint

const (
	AcctClassificationPersonal acctClassification = 1 + iota
	AcctClassificationBusiness
	AcctClassificationCorporate
	AcctClassificationOther
)

var acctClassifications = [...]string{"PERSONAL", "BUSINESS", "CORPORATE", "OTHER"}

func (e acctClassification) Valid() bool {
	return e >= AcctClassificationPersonal && e <= AcctClassificationOther
}

func (e acctClassification) String() string {
	if e.Valid() {
		return acctClassifications[e-1]
	}
	return fmt.Sprintf("invalid acctClassification (%d)", e)
}

func (e *acctClassification) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range acctClassifications {
		if s == value {
			*e = acctClassification(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid AcctClassification: \"" + in + "\"")
}

func (e *acctClassification) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *acctClassification) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid AcctClassification")
	}
	enc.EncodeElement(acctClassifications[*e-1], start)
	return nil
}

func NewAcctClassification(s string) (acctClassification, error) {
	var e acctClassification
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type svcStatus uint

const (
	SvcStatusAvail svcStatus = 1 + iota
	SvcStatusPend
	SvcStatusActive
)

var svcStatuss = [...]string{"AVAIL", "PEND", "ACTIVE"}

func (e svcStatus) Valid() bool {
	return e >= SvcStatusAvail && e <= SvcStatusActive
}

func (e svcStatus) String() string {
	if e.Valid() {
		return svcStatuss[e-1]
	}
	return fmt.Sprintf("invalid svcStatus (%d)", e)
}

func (e *svcStatus) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range svcStatuss {
		if s == value {
			*e = svcStatus(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid SvcStatus: \"" + in + "\"")
}

func (e *svcStatus) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *svcStatus) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid SvcStatus")
	}
	enc.EncodeElement(svcStatuss[*e-1], start)
	return nil
}

func NewSvcStatus(s string) (svcStatus, error) {
	var e svcStatus
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type usProductType uint

const (
	UsProductType401K usProductType = 1 + iota
	UsProductType403B
	UsProductTypeIRA
	UsProductTypeKEOGH
	UsProductTypeOther
	UsProductTypeSARSEP
	UsProductTypeSimple
	UsProductTypeNormal
	UsProductTypeTDA
	UsProductTypeTrust
	UsProductTypeUGMA
)

var usProductTypes = [...]string{"401K", "403B", "IRA", "KEOGH", "OTHER", "SARSEP", "SIMPLE", "NORMAL", "TDA", "TRUST", "UGMA"}

func (e usProductType) Valid() bool {
	return e >= UsProductType401K && e <= UsProductTypeUGMA
}

func (e usProductType) String() string {
	if e.Valid() {
		return usProductTypes[e-1]
	}
	return fmt.Sprintf("invalid usProductType (%d)", e)
}

func (e *usProductType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range usProductTypes {
		if s == value {
			*e = usProductType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid UsProductType: \"" + in + "\"")
}

func (e *usProductType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *usProductType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if *e == 0 {
		return nil
	} else if !e.Valid() {
		return errors.New("Invalid UsProductType")
	}
	enc.EncodeElement(usProductTypes[*e-1], start)
	return nil
}

func NewUsProductType(s string) (usProductType, error) {
	var e usProductType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}
